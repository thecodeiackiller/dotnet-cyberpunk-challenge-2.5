using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using dotnet_cyberpunk_challenge_2._5.malware_daemons.lib;

namespace dotnet_cyberpunk_challenge_2._5.malware_daemons
{
    public class KuangGradeSixMalware : KuangDaemonFamilyBase
    {
        // Objective: We need a variant of the Kuang malware that specifically is able to do some basic recon
        // We're not too concerned about breaking ice. We plan to use this on auxiliary systems to collect data
        // for later penetrations. The main thing we need FROM YOU is to add some functionality to:
        //  0. Initialize the malware
        //  1. Get the process list. We can use this list to get the memory mappings of the given process
        //  2. Get the memory mapping of a given process

        /*TODO: Go ahead and create a constructor just in case. 
        It's gonna be empty but maybe we'll add stuff to it later.
        It should be public.
        */

        public KuangGradeSixMalware() { }

        public async Task Initialize()
        {
            ArasakaServerConnection var = await GetCurrentArasakaConnection();

        }

        public override Task<ArasakaMessageRoot> GetIceTypeOnRemote()
        {
            throw new NotImplementedException();
        }

        public override void IceBreak()
        {
            throw new NotImplementedException();
        }

        public override Task SetupIceBreakerTunnelToTarget()
        {
            throw new NotImplementedException();
        }

        /*TODO: Go ahead and create a public function called Initialize()
            - This will be a public function
            - It'll be an async function (because inside the function needs to use `await` when making a network request).
            *hint*: This keyword goes in-between the access-modifier and the return type
            - It needs to return `Task` datatype because it's an async function. 
            Examples on usage: If you wanted to return a string from an async
            function then you would set the return type to `Task<string>`. If you wanted to return a list of strings then
            you would use `Task<List<string>>`.
            - This method needs be to called `Initialize()`
            - In the definition this methods needs to call a method in the base class to Get the Current Arasaka Connection 
            with no arguments passed to it.
            - *NOTE: When we call the method to get the connection we need to add the `await` keyword before it (ex. is below)
            so that C# knows to wait until the network connection (e.g. HTTP request) is complete. 
            Otherwise your program will get all jumbled and try to continue executing before the 
            connection request is complete; in the case that it gets jumbled you'll notice that execution just *stops* suddenly without warning, 
            even in debug mode.
            E.g. `await SomeMethod();`
            - *Optional* If you want to you can make a variable to assign/bind the object returned from that method,
            the datatype will be an ArasakaServerConnection. You don't need to do this but you can; For details on why you don't
            need to do so, please check out the definition of the method.
        */

        /*TODO: The base class has a number of abstract methods. You can simply implement those methods
        with the exact same signature (except: use the "override" keyword instead of abstract).
        The body of the overridden methods can either be "throw new NotImplementedException()" or whatever
        behavior you come up with. The world is your oyster :)
        */

        public async Task<List<ArasakaMessageProcessList>> GetProcessList()
        {
            var connectionJson = await CurrentServerConnection.SendRequest("process-list");
            return connectionJson.content.processList;
        }

        /*TODO: We need to make a public function called GetProcessList()
            - This will be a public function
            - It'll be an async function (because inside the function needs to use `await` when making a network request)
            - It needs to return `Task<List<ArasakaMessageProcessList>>` datatype because it's an async function
            - It needs to be called `GetProcessList()`
            - It needs to call the `SendRequest()` method on the `CurrentServerConnection` property. You will pass
            a single string argument of `"process-list"` to the method.
            - Before the property & method call of SendRequest() we need to use the `await` keyword before it
            so that C# knows to wait until the network is complete. Otherwise your program will get all 
            jumbled and try to continue executing before the connection request is complete.
            - make a variable to assign/bind the object returned from that method,
            the datatype will be an ArasakaMessageRoot. You'll have to F12 into the class to see
            what properties are on it.
            - Supposed to be properties here...??
            - TIP: Something that helps me is to get the response object back and stored into a variable, set a breakpoint, run in debug mode,
            and make sure to pause execution right after the response is bound to a variable and look at how the data is structured. In this 
            way you can see at runtime the structure of the data and type out the code for how to you need to process the data, then 
            save changes + restart the app and make sure your processing works.
        */

        /*
        TODO: Assuming you were able to make the `GetProcessList()` now we need you to make a GetProcessMemoryMapping. This will
            be used later to create an ICE Breaker that's able to analyze the memory addresses and come up with vulnerable areas
            to inject our Kuang malware.
            - This will be a public function
            - It'll be an async function (because inside the function needs to use `await` when making a network request)
            - It needs to return `Task<IEnumerable<string>>` datatype because it's an async function
            - It will be named `GetProcessMemoryMapping()`
            - In the body of the function we need to call the `GetProcessList()` and make sure to `await` that method call.
            This function will return an object. Make a variable called `arasakaMessageProcessLists` that will bind to that
            returned object. It'll be of the type `List<ArasakaMessageProcessList>`
            - Next we need to do something a bit different and use LINQ to grab out ONLY the `memoryStartingAddress` property
            To do this we need to use `arasakaMessageProcessLists` with the `.Select()` method on it.
            Inside the parentheses of `Select()` we need to use an anonymous function. It'll be like this:
                - `.Select(pl => pl.WhateverPropertyYouSpecify)` but instead of `WhateverPropertyYouSpecify` you need to specify the
                `memoryStartingAddress`
        */

        public async Task<IEnumerable<string>> GetProcessMemoryMapping()
        {
           var processList =  await GetProcessList();

            var onlyMemAddresses = processList.Select(pl => pl.memoryStartingAddress);
            return onlyMemAddresses;
            
            // This function will return an object of the type List<ArasakaMessageProcessList> - exactly what was returned in GetProcesslist 
            // Now we need to add only the memoryStartingAddress property
        }
    }
}